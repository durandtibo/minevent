{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p><code>minevent</code> is a Python library that provides a minimal event system for Machine Learning. It allows to customize a code by adding some piece of code that are executed when an event is fired. <code>minevent</code> is organized around three main concepts:</p> <ul> <li>event which defines the thing that should happen.</li> <li>event handler which is the piece of code to execute when the event happens</li> <li>event manager which is responsible to manage the events and event handlers.</li> </ul> <p>The goal of this documentation is to explain how the event system works and how to use it. The library provides some implemented modules, but it is possible to extend it. It is possible to use all the components or just a subset based on the need. For example, an event handler can be used without the event manager.</p>"},{"location":"#motivation","title":"Motivation","text":"<p><code>minevent</code> provides a minimal event system to customize a piece of code without changing its implementation. Below is an example on how to use <code>minevent</code> library.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def say_something(manager: EventManager) -&gt; None:\n...     print(\"Hello, I am Bob!\")\n...     manager.trigger_event(\"after\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; say_something(manager)\nHello, I am Bob!\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"after\", EventHandler(hello_handler))\n&gt;&gt;&gt; say_something(manager)\nHello, I am Bob!\nHello!\n</code></pre> <p>It allows to customize the function <code>say_something</code> without changing its implementation. Please read the quickstart page to learn more about the library.</p>"},{"location":"#api-stability","title":"API stability","text":"<p> While <code>minevent</code> is in development stage, no API is guaranteed to be stable from one release to the next. In fact, it is very likely that the API will change multiple times before a stable 1.0.0 release. In practice, this means that upgrading <code>minevent</code> to a new version will possibly break any code that was using the old version of <code>minevent</code>.</p>"},{"location":"#license","title":"License","text":"<p><code>minevent</code> is licensed under BSD 3-Clause \"New\" or \"Revised\" license available in LICENSE file.</p>"},{"location":"architecture/","title":"Architecture and Design Principles","text":"<p>This document describes the architecture and design principles of <code>minevent</code>.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p><code>minevent</code> is designed as a minimal event system with three core components:</p> <ol> <li>Events - String identifiers representing things that happen</li> <li>Event Handlers - Code that executes when events occur</li> <li>Event Manager - Coordinator that manages handlers and triggers events</li> </ol>"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#1-simplicity-first","title":"1. Simplicity First","text":"<p><code>minevent</code> prioritizes simplicity over features:</p> <ul> <li>Minimal API surface area</li> <li>Easy to understand and use</li> <li>No complex configuration required</li> <li>Clear separation of concerns</li> </ul> <p>Example: Events are simply strings, not complex objects.</p> <pre><code># Simple and clear\nmanager.trigger_event(\"training_complete\")\n\n# Not: complex event objects\n# manager.trigger_event(Event(name=\"training_complete\", priority=1, ...))\n</code></pre>"},{"location":"architecture/#2-synchronous-by-design","title":"2. Synchronous by Design","text":"<p>All event handling is synchronous:</p> <ul> <li>Handlers execute in the order they were registered</li> <li>Easy to reason about execution flow</li> <li>Simpler debugging and testing</li> <li>No threading or async complexity</li> </ul> <p>Rationale: ML workflows are often sequential and benefit from deterministic execution order.</p>"},{"location":"architecture/#3-explicit-over-implicit","title":"3. Explicit Over Implicit","text":"<p>All actions are explicit:</p> <ul> <li>Must explicitly register handlers</li> <li>Must explicitly trigger events</li> <li>Must explicitly pass arguments to handlers</li> </ul> <p>Example:</p> <pre><code># Explicit registration\nmanager.add_event_handler(\"event\", EventHandler(handler))\n\n# Explicit triggering\nmanager.trigger_event(\"event\")\n\n# Not: implicit auto-registration or magic discovery\n</code></pre>"},{"location":"architecture/#4-extensibility-through-composition","title":"4. Extensibility Through Composition","text":"<p>Extend functionality by composing handlers and conditions:</p> <ul> <li>Base classes for custom implementations</li> <li>Conditional handlers combine handlers and conditions</li> <li>No inheritance-heavy design</li> </ul> <p>Example:</p> <pre><code># Compose handlers with conditions\nhandler = ConditionalEventHandler(my_function, PeriodicCondition(freq=5))\n\n\n# Custom conditions by implementing BaseCondition\nclass MyCondition(BaseCondition):\n    def evaluate(self) -&gt; bool:\n        return custom_logic()\n</code></pre>"},{"location":"architecture/#5-zero-magic","title":"5. Zero Magic","text":"<p>No hidden behavior or surprising actions:</p> <ul> <li>No global state</li> <li>No automatic discovery</li> <li>No reflection or metaclasses</li> <li>What you write is what happens</li> </ul>"},{"location":"architecture/#core-components","title":"Core Components","text":""},{"location":"architecture/#event","title":"Event","text":"<p>Design: Events are represented as case-sensitive strings.</p> <p>Rationale: - Simple and universal - Easy to type and understand - No serialization issues - Language-agnostic concept</p> <p>Best Practices: - Use descriptive names - Follow consistent naming convention - Consider hierarchical naming for complex systems</p>"},{"location":"architecture/#event-handler","title":"Event Handler","text":"<p>Design: Handlers wrap callable functions with optional arguments.</p> <p>Class Hierarchy:</p> <pre><code>BaseEventHandler (abstract)\n    \u251c\u2500\u2500 BaseEventHandlerWithArguments (abstract)\n    \u2502   \u251c\u2500\u2500 EventHandler\n    \u2502   \u2514\u2500\u2500 ConditionalEventHandler\n    \u2514\u2500\u2500 [Your custom handlers]\n</code></pre> <p>Key Methods: - <code>handle()</code>: Execute the handler logic - <code>equal()</code>: Compare handlers for equality</p> <p>Rationale: - Separation between handler logic and handler metadata - Enables handler comparison for deduplication - Supports both simple and complex use cases</p>"},{"location":"architecture/#event-manager","title":"Event Manager","text":"<p>Design: Central coordinator using a dictionary to map events to handler lists.</p> <p>Internal Structure:</p> <pre><code>{\n    \"event1\": [handler1, handler2, handler3],\n    \"event2\": [handler4, handler5],\n    # ...\n}\n</code></pre> <p>Rationale: - Simple dictionary lookup for handlers - Preserves registration order - Easy to implement and understand</p> <p>Key Operations: - <code>O(1)</code> handler registration - <code>O(n)</code> event triggering (n = number of handlers) - <code>O(n)</code> handler lookup (n = total handlers)</p>"},{"location":"architecture/#conditional-execution","title":"Conditional Execution","text":"<p>Design: <code>ConditionalEventHandler</code> wraps a handler with a condition.</p> <p>Architecture:</p> <pre><code>ConditionalEventHandler\n    \u251c\u2500\u2500 Handler (BaseEventHandler)\n    \u2514\u2500\u2500 Condition (BaseCondition)\n</code></pre> <p>Execution Flow:</p> <pre><code>trigger_event()\n    \u251c\u2500\u2500 Get handlers for event\n    \u2514\u2500\u2500 For each handler:\n        \u251c\u2500\u2500 If ConditionalEventHandler:\n        \u2502   \u251c\u2500\u2500 Evaluate condition\n        \u2502   \u2514\u2500\u2500 If True: execute handler\n        \u2514\u2500\u2500 Else: execute handler\n</code></pre> <p>Rationale: - Separates \"what\" (handler) from \"when\" (condition) - Conditions are reusable across handlers - Conditions can maintain state between evaluations</p>"},{"location":"architecture/#event-flow","title":"Event Flow","text":""},{"location":"architecture/#registration-flow","title":"Registration Flow","text":"<pre><code>1. User creates EventHandler\n   EventHandler(function, args, kwargs)\n\n2. User registers handler\n   manager.add_event_handler(\"event\", handler)\n\n3. Manager stores handler\n   _event_handlers[\"event\"].append(handler)\n</code></pre>"},{"location":"architecture/#triggering-flow","title":"Triggering Flow","text":"<pre><code>1. User triggers event\n   manager.trigger_event(\"event\")\n\n2. Manager updates state\n   _last_triggered_event = \"event\"\n\n3. Manager gets handlers\n   handlers = _event_handlers[\"event\"]\n\n4. Manager executes each handler\n   for handler in handlers:\n       handler.handle()\n</code></pre>"},{"location":"architecture/#handler-execution","title":"Handler Execution","text":"<pre><code>For EventHandler:\n    handler(*handler_args, **handler_kwargs)\n\nFor ConditionalEventHandler:\n    if condition.evaluate():\n        handler(*handler_args, **handler_kwargs)\n</code></pre>"},{"location":"architecture/#comparison-with-other-systems","title":"Comparison with Other Systems","text":""},{"location":"architecture/#vs-pythons-signal-module","title":"vs Python's <code>signal</code> module","text":"Feature minevent signal Use case Application events Unix signals Event types Arbitrary strings Predefined signals Handler arguments Flexible Fixed signature Conditional execution Built-in Manual Event manager Explicit Global"},{"location":"architecture/#vs-pydispatcher-blinker","title":"vs PyDispatcher / blinker","text":"Feature minevent PyDispatcher/blinker Dependencies Minimal (coola) None Event metadata None Supported Weak references No Yes Sender/receiver No Yes Async support No Limited <p>Why minevent?: Simpler, more focused on ML workflows, easier to understand.</p>"},{"location":"architecture/#vs-observer-pattern-manual","title":"vs Observer Pattern (Manual)","text":"Feature minevent Manual Observer Boilerplate Minimal High Conditional execution Built-in Manual Event naming String-based Type-based Learning curve Low Moderate"},{"location":"architecture/#extension-points","title":"Extension Points","text":""},{"location":"architecture/#custom-event-handlers","title":"Custom Event Handlers","text":"<p>Implement <code>BaseEventHandler</code>:</p> <pre><code>class MyEventHandler(BaseEventHandler):\n    def handle(self) -&gt; None:\n        # Custom logic\n        pass\n\n    def equal(self, other: Any) -&gt; bool:\n        # Custom comparison\n        return isinstance(other, MyEventHandler)\n</code></pre> <p>Use Cases: - Handlers with complex state - Handlers that modify themselves - Handlers with special lifecycle</p>"},{"location":"architecture/#custom-conditions","title":"Custom Conditions","text":"<p>Implement <code>BaseCondition</code>:</p> <pre><code>class MyCondition(BaseCondition):\n    def evaluate(self) -&gt; bool:\n        # Custom logic\n        return some_condition\n\n    def equal(self, other: Any) -&gt; bool:\n        # Custom comparison\n        return isinstance(other, MyCondition)\n</code></pre> <p>Use Cases: - Time-based conditions - State-based conditions - Metric-threshold conditions - Complex multi-condition logic</p>"},{"location":"architecture/#custom-event-manager","title":"Custom Event Manager","text":"<p>While not common, you can create custom event managers:</p> <pre><code>class MyEventManager:\n    # Must implement the same interface\n    def add_event_handler(self, event: str, handler: BaseEventHandler): ...\n    def trigger_event(self, event: str): ...\n    def has_event_handler(self, handler: BaseEventHandler, event: str | None): ...\n    def remove_event_handler(self, event: str, handler: BaseEventHandler): ...\n    def reset(self): ...\n</code></pre> <p>Use Cases: - Thread-safe event managers - Event managers with persistence - Event managers with priorities - Event managers with event history</p>"},{"location":"architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/#time-complexity","title":"Time Complexity","text":"Operation Complexity Notes Add handler O(1) Append to list Trigger event O(n) n = handlers for event Has handler O(m) m = total handlers Remove handler O(n) n = handlers for event"},{"location":"architecture/#space-complexity","title":"Space Complexity","text":"<ul> <li>O(e \u00d7 h) where e = number of events, h = average handlers per event</li> <li>Minimal overhead per handler (~100 bytes)</li> </ul>"},{"location":"architecture/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Minimize handler count: Combine related operations</li> <li>Use conditions: Avoid unnecessary handler execution</li> <li>Keep handlers lightweight: Move heavy work elsewhere</li> <li>Reuse handlers: Same handler for multiple events</li> </ol>"},{"location":"architecture/#thread-safety","title":"Thread Safety","text":"<p>Status: <code>minevent</code> is not thread-safe by design.</p> <p>Rationale: - Simpler implementation - Better performance for single-threaded use - Most ML workflows are single-threaded - Users can add synchronization if needed</p> <p>Thread-Safe Usage:</p> <pre><code>import threading\n\n\nclass ThreadSafeEventManager:\n    def __init__(self):\n        self._manager = EventManager()\n        self._lock = threading.Lock()\n\n    def add_event_handler(self, event, handler):\n        with self._lock:\n            self._manager.add_event_handler(event, handler)\n\n    def trigger_event(self, event):\n        with self._lock:\n            self._manager.trigger_event(event)\n</code></pre>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<ul> <li>Test each component in isolation</li> <li>Mock dependencies</li> <li>High coverage (&gt;90%)</li> </ul>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test component interactions</li> <li>Test real-world scenarios</li> <li>Test error conditions</li> </ul>"},{"location":"architecture/#doctest","title":"Doctest","text":"<ul> <li>Examples in docstrings are tested</li> <li>Ensures documentation accuracy</li> <li>Provides usage examples</li> </ul>"},{"location":"architecture/#future-considerations","title":"Future Considerations","text":"<p>Potential future enhancements (without breaking simplicity):</p> <ol> <li>Event Metadata: Optional data passed with events</li> <li>Handler Priorities: Control execution order within an event</li> <li>Event Filtering: Filter events based on criteria</li> <li>Event History: Optional tracking of past events</li> <li>Async Support: Optional async handler execution</li> </ol> <p>All enhancements must maintain: - Simplicity - Backward compatibility - Clear documentation - Optional (not required for basic usage)</p>"},{"location":"architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"architecture/#why-strings-for-events","title":"Why Strings for Events?","text":"<p>Alternatives Considered: - Enum types - Custom Event classes - Integer IDs</p> <p>Chosen: Strings</p> <p>Reasons: - Universal and simple - Easy to understand - No import dependencies - Flexible naming - Human-readable</p>"},{"location":"architecture/#why-synchronous-only","title":"Why Synchronous Only?","text":"<p>Alternatives Considered: - Async/await support - Threading - Multiprocessing</p> <p>Chosen: Synchronous</p> <p>Reasons: - Simpler to understand - Easier to debug - Deterministic execution - Sufficient for ML workflows - Users can add async if needed</p>"},{"location":"architecture/#why-explicit-event-manager","title":"Why Explicit Event Manager?","text":"<p>Alternatives Considered: - Global event bus - Singleton manager - Module-level functions</p> <p>Chosen: Explicit manager instance</p> <p>Reasons: - No hidden global state - Easier to test - Multiple managers possible - Clear ownership - Explicit is better than implicit</p>"},{"location":"architecture/#conclusion","title":"Conclusion","text":"<p><code>minevent</code> is designed to be: - Simple: Easy to learn and use - Explicit: No surprises or magic - Extensible: Customize through composition - Focused: Does one thing well - Reliable: Well-tested and documented</p> <p>The architecture supports these goals while remaining flexible enough for diverse use cases in machine learning and beyond.</p>"},{"location":"best_practices/","title":"Best Practices","text":"<p>This guide provides recommendations for using <code>minevent</code> effectively in your projects.</p>"},{"location":"best_practices/#event-naming","title":"Event Naming","text":""},{"location":"best_practices/#use-clear-descriptive-names","title":"Use Clear, Descriptive Names","text":"<p>Event names should clearly describe what happened or will happen:</p> <pre><code># Good\nmanager.trigger_event(\"training_epoch_completed\")\nmanager.trigger_event(\"model_checkpoint_saved\")\nmanager.trigger_event(\"validation_started\")\n\n# Less clear\nmanager.trigger_event(\"event1\")\nmanager.trigger_event(\"done\")\nmanager.trigger_event(\"x\")\n</code></pre>"},{"location":"best_practices/#use-consistent-naming-conventions","title":"Use Consistent Naming Conventions","text":"<p>Choose a naming convention and stick to it throughout your project:</p> <pre><code># Option 1: Snake case with verb in past tense\n\"training_started\"\n\n\"epoch_completed\"\n\"validation_finished\"\n\n# Option 2: Namespace-style with present tense\n\"training.start\"\n\"training.epoch.complete\"\n\"validation.finish\"\n</code></pre>"},{"location":"best_practices/#use-hierarchical-event-names","title":"Use Hierarchical Event Names","text":"<p>For complex systems, use hierarchical naming to organize events:</p> <pre><code># Training lifecycle\n\"training.start\"\n\n\"training.epoch.start\"\n\"training.batch.start\"\n\"training.batch.end\"\n\"training.epoch.end\"\n\"training.end\"\n\n# Model lifecycle\n\"model.created\"\n\"model.compiled\"\n\"model.saved\"\n</code></pre>"},{"location":"best_practices/#event-handler-design","title":"Event Handler Design","text":""},{"location":"best_practices/#keep-handlers-focused","title":"Keep Handlers Focused","text":"<p>Each handler should do one thing well:</p> <pre><code># Good: Separate handlers for separate concerns\ndef log_metrics(metrics):\n    logger.info(f\"Metrics: {metrics}\")\n\n\ndef save_checkpoint(model, epoch):\n    torch.save(model.state_dict(), f\"checkpoint_epoch_{epoch}.pt\")\n\n\ndef update_progress_bar(current, total):\n    progress_bar.update(current / total)\n\n\n# Less ideal: One handler doing multiple things\ndef do_everything(model, metrics, epoch, current, total):\n    logger.info(f\"Metrics: {metrics}\")\n    torch.save(model.state_dict(), f\"checkpoint_epoch_{epoch}.pt\")\n    progress_bar.update(current / total)\n</code></pre>"},{"location":"best_practices/#handle-exceptions-gracefully","title":"Handle Exceptions Gracefully","text":"<p>Protect your main logic from handler failures:</p> <pre><code>from minevent import EventHandler\n\n\ndef safe_handler(*args, **kwargs):\n    try:\n        # Your handler logic\n        process_data(*args, **kwargs)\n    except Exception as e:\n        logger.error(f\"Handler failed: {e}\")\n        # Optionally re-raise if critical\n        # raise\n\n\nhandler = EventHandler(safe_handler)\n</code></pre>"},{"location":"best_practices/#use-type-hints","title":"Use Type Hints","text":"<p>Make your handlers more maintainable with type hints:</p> <pre><code>from typing import Dict, Any\n\n\ndef log_metrics(metrics: Dict[str, float], epoch: int) -&gt; None:\n    \"\"\"Log training metrics for the current epoch.\n\n    Args:\n        metrics: Dictionary of metric names to values\n        epoch: Current training epoch number\n    \"\"\"\n    logger.info(f\"Epoch {epoch}: {metrics}\")\n\n\nhandler = EventHandler(\n    log_metrics, handler_kwargs={\"metrics\": {\"loss\": 0.5}, \"epoch\": 1}\n)\n</code></pre>"},{"location":"best_practices/#event-manager-usage","title":"Event Manager Usage","text":""},{"location":"best_practices/#centralize-event-manager-creation","title":"Centralize Event Manager Creation","text":"<p>Create the event manager in one place and pass it where needed:</p> <pre><code># Good: Create once, pass around\ndef main():\n    manager = EventManager()\n    setup_handlers(manager)\n    trainer = Trainer(manager)\n    trainer.train()\n\n\ndef setup_handlers(manager: EventManager):\n    manager.add_event_handler(\"epoch_end\", EventHandler(save_checkpoint))\n    manager.add_event_handler(\"training_end\", EventHandler(log_summary))\n\n\n# Avoid: Global event manager\n# MANAGER = EventManager()  # Global state can be problematic\n</code></pre>"},{"location":"best_practices/#check-before-adding-duplicate-handlers","title":"Check Before Adding Duplicate Handlers","text":"<p>Prevent duplicate handler registrations:</p> <pre><code># Add handler only if not already present\nhandler = EventHandler(my_function)\nif not manager.has_event_handler(handler, \"my_event\"):\n    manager.add_event_handler(\"my_event\", handler)\n</code></pre>"},{"location":"best_practices/#clean-up-when-done","title":"Clean Up When Done","text":"<p>Reset or properly dispose of event managers when they're no longer needed:</p> <pre><code>try:\n    # Training loop\n    trainer.train(manager)\nfinally:\n    # Clean up\n    manager.reset()\n</code></pre>"},{"location":"best_practices/#conditional-event-handling","title":"Conditional Event Handling","text":""},{"location":"best_practices/#use-conditions-for-periodic-operations","title":"Use Conditions for Periodic Operations","text":"<p>For operations that shouldn't happen every time:</p> <pre><code>from minevent import ConditionalEventHandler, PeriodicCondition\n\n# Save checkpoint every 10 epochs\nsave_handler = ConditionalEventHandler(save_checkpoint, PeriodicCondition(freq=10))\nmanager.add_event_handler(\"epoch_end\", save_handler)\n\n# Log metrics every 100 batches\nlog_handler = ConditionalEventHandler(log_batch_metrics, PeriodicCondition(freq=100))\nmanager.add_event_handler(\"batch_end\", log_handler)\n</code></pre>"},{"location":"best_practices/#integration-patterns","title":"Integration Patterns","text":""},{"location":"best_practices/#ml-training-pipeline-pattern","title":"ML Training Pipeline Pattern","text":"<pre><code>class Trainer:\n    def __init__(self, model, manager: EventManager):\n        self.model = model\n        self.manager = manager\n\n    def train(self, epochs: int, train_loader, val_loader):\n        self.manager.trigger_event(\"training_start\")\n\n        for epoch in range(epochs):\n            self.manager.trigger_event(\"epoch_start\")\n\n            # Training\n            train_loss = self._train_epoch(train_loader)\n            self.manager.trigger_event(\"training_epoch_end\")\n\n            # Validation\n            val_loss = self._validate(val_loader)\n            self.manager.trigger_event(\"validation_epoch_end\")\n\n            self.manager.trigger_event(\"epoch_end\")\n\n        self.manager.trigger_event(\"training_end\")\n\n    def _train_epoch(self, train_loader):\n        for batch in train_loader:\n            self.manager.trigger_event(\"batch_start\")\n            loss = self._process_batch(batch)\n            self.manager.trigger_event(\"batch_end\")\n        return loss\n</code></pre>"},{"location":"best_practices/#plugin-system-pattern","title":"Plugin System Pattern","text":"<pre><code>class PluginManager:\n    \"\"\"Manage plugins using event system.\"\"\"\n\n    def __init__(self):\n        self.event_manager = EventManager()\n        self.plugins = []\n\n    def register_plugin(self, plugin):\n        \"\"\"Register a plugin and its event handlers.\"\"\"\n        self.plugins.append(plugin)\n        plugin.setup(self.event_manager)\n\n    def trigger(self, event: str, **kwargs):\n        \"\"\"Trigger event with data.\"\"\"\n        # Store kwargs somewhere accessible to handlers\n        self.event_manager.trigger_event(event)\n\n\n# Plugin implementation\nclass LoggingPlugin:\n    def setup(self, manager: EventManager):\n        manager.add_event_handler(\n            \"model_trained\", EventHandler(self.log_training_complete)\n        )\n\n    def log_training_complete(self):\n        print(\"Training completed!\")\n</code></pre>"},{"location":"best_practices/#callback-system-pattern","title":"Callback System Pattern","text":"<pre><code>class CallbackSystem:\n    \"\"\"Wrap minevent for a cleaner callback API.\"\"\"\n\n    def __init__(self):\n        self._manager = EventManager()\n\n    def on(self, event: str, callback, condition=None):\n        \"\"\"Register a callback for an event.\"\"\"\n        if condition:\n            handler = ConditionalEventHandler(callback, condition)\n        else:\n            handler = EventHandler(callback)\n        self._manager.add_event_handler(event, handler)\n\n    def emit(self, event: str):\n        \"\"\"Emit an event.\"\"\"\n        self._manager.trigger_event(event)\n\n\n# Usage\ncallbacks = CallbackSystem()\ncallbacks.on(\"training_complete\", send_notification)\ncallbacks.on(\"checkpoint\", save_model, condition=PeriodicCondition(freq=10))\n</code></pre>"},{"location":"best_practices/#testing","title":"Testing","text":""},{"location":"best_practices/#test-event-handlers-independently","title":"Test Event Handlers Independently","text":"<pre><code>def test_handler():\n    \"\"\"Test handler logic without event manager.\"\"\"\n    # Arrange\n    handler = EventHandler(my_function, handler_args=(\"test\",))\n\n    # Act\n    handler.handle()\n\n    # Assert - verify expected behavior\n    assert expected_result == actual_result\n</code></pre>"},{"location":"best_practices/#mock-event-handlers-in-tests","title":"Mock Event Handlers in Tests","text":"<pre><code>from unittest.mock import Mock\n\n\ndef test_event_system():\n    \"\"\"Test event system with mock handlers.\"\"\"\n    manager = EventManager()\n    mock_handler = Mock()\n\n    manager.add_event_handler(\"test_event\", EventHandler(mock_handler))\n    manager.trigger_event(\"test_event\")\n\n    mock_handler.assert_called_once()\n</code></pre>"},{"location":"best_practices/#test-event-flow","title":"Test Event Flow","text":"<pre><code>def test_training_events():\n    \"\"\"Test that training triggers expected events.\"\"\"\n    manager = EventManager()\n    events_triggered = []\n\n    def track_event(event_name):\n        events_triggered.append(event_name)\n\n    manager.add_event_handler(\"start\", EventHandler(track_event, (\"start\",)))\n    manager.add_event_handler(\"end\", EventHandler(track_event, (\"end\",)))\n\n    # Simulate training\n    manager.trigger_event(\"start\")\n    manager.trigger_event(\"end\")\n\n    assert events_triggered == [\"start\", \"end\"]\n</code></pre>"},{"location":"best_practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"best_practices/#minimize-handler-count","title":"Minimize Handler Count","text":"<p>Too many handlers can slow down event triggering:</p> <pre><code># Good: One handler for related operations\ndef batch_operations(batch):\n    log_batch(batch)\n    update_metrics(batch)\n    check_conditions(batch)\n\n\nmanager.add_event_handler(\"batch_end\", EventHandler(batch_operations))\n\n# Less efficient: Multiple handlers for small operations\n# manager.add_event_handler(\"batch_end\", EventHandler(log_batch))\n# manager.add_event_handler(\"batch_end\", EventHandler(update_metrics))\n# manager.add_event_handler(\"batch_end\", EventHandler(check_conditions))\n</code></pre>"},{"location":"best_practices/#use-conditional-handlers-for-infrequent-operations","title":"Use Conditional Handlers for Infrequent Operations","text":"<p>Don't execute expensive operations every time:</p> <pre><code># Good: Only save checkpoint periodically\nmanager.add_event_handler(\n    \"epoch_end\", ConditionalEventHandler(save_checkpoint, PeriodicCondition(freq=10))\n)\n\n# Less efficient: Save every epoch when not needed\n# manager.add_event_handler(\"epoch_end\", EventHandler(save_checkpoint))\n</code></pre>"},{"location":"best_practices/#profile-handler-performance","title":"Profile Handler Performance","text":"<p>Identify slow handlers:</p> <pre><code>import time\n\n\ndef profiled_handler(*args, **kwargs):\n    start = time.time()\n    actual_handler(*args, **kwargs)\n    elapsed = time.time() - start\n    if elapsed &gt; 0.1:  # Log if takes more than 100ms\n        logger.warning(f\"Handler took {elapsed:.2f}s\")\n</code></pre>"},{"location":"best_practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"best_practices/#avoid-modifying-state-during-event-triggering","title":"Avoid Modifying State During Event Triggering","text":"<pre><code># Problematic: Removing handlers during event triggering\ndef problematic_handler(manager, event, handler):\n    # This can cause issues if called during event triggering\n    manager.remove_event_handler(event, handler)\n\n\n# Better: Flag for removal, clean up later\nhandlers_to_remove = []\n\n\ndef safe_handler(event, handler):\n    handlers_to_remove.append((event, handler))\n\n\n# Clean up after event triggering is complete\nfor event, handler in handlers_to_remove:\n    manager.remove_event_handler(event, handler)\n</code></pre>"},{"location":"best_practices/#dont-rely-on-execution-order-across-events","title":"Don't Rely on Execution Order Across Events","text":"<pre><code># Problematic: Assuming event order\nmanager.trigger_event(\"event1\")\nmanager.trigger_event(\"event2\")\n# Handlers for event1 and event2 may have side effects,\n# but don't assume event1 handlers complete before event2 triggers\n\n# Better: Use explicit ordering within the same event\nmanager.add_event_handler(\"event\", EventHandler(step1))\nmanager.add_event_handler(\"event\", EventHandler(step2))  # Runs after step1\n</code></pre>"},{"location":"best_practices/#avoid-circular-event-triggering","title":"Avoid Circular Event Triggering","text":"<pre><code># Problematic: Handler triggers the same event\ndef recursive_handler(manager):\n    manager.trigger_event(\"my_event\")  # This creates infinite recursion!\n\n\n# Better: Use different events or add guards\ndef safe_handler(manager, depth=0):\n    if depth &gt; 0:\n        return\n    # Do work\n    manager.trigger_event(\"next_event\")\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-minevent","title":"What is minevent?","text":"<p><code>minevent</code> is a minimal, lightweight event system for Python, designed specifically with Machine Learning workflows in mind. It provides a simple way to add extensibility to your code by allowing you to register event handlers that execute when specific events are triggered.</p>"},{"location":"faq/#why-should-i-use-minevent","title":"Why should I use minevent?","text":"<p><code>minevent</code> is useful when you want to:</p> <ul> <li>Add hooks or callbacks to your code without modifying its core logic</li> <li>Implement plugin-like functionality</li> <li>Separate concerns in your ML training pipelines</li> <li>Create extensible frameworks</li> <li>Add logging, monitoring, or debugging capabilities without cluttering your main code</li> </ul>"},{"location":"faq/#how-is-minevent-different-from-other-event-systems","title":"How is minevent different from other event systems?","text":"<p><code>minevent</code> is designed to be minimal and focused. It:</p> <ul> <li>Has minimal dependencies (only requires <code>coola</code>)</li> <li>Is synchronous by design (simpler reasoning about execution order)</li> <li>Provides conditional event handling out of the box</li> <li>Is specifically tailored for ML workflows but works for any Python application</li> </ul>"},{"location":"faq/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p><code>minevent</code> currently supports Python 3.10 and above. See the compatibility table in the README for specific version requirements.</p>"},{"location":"faq/#how-do-i-install-minevent","title":"How do I install minevent?","text":"<p>The simplest way is via pip:</p> <pre><code>pip install minevent\n</code></pre> <p>For development or contributing, see the Get Started guide.</p>"},{"location":"faq/#can-i-use-minevent-with-other-ml-frameworks","title":"Can I use minevent with other ML frameworks?","text":"<p>Yes! <code>minevent</code> is framework-agnostic and can be integrated with PyTorch, TensorFlow, scikit-learn, or any other Python-based ML framework.</p>"},{"location":"faq/#usage-questions","title":"Usage Questions","text":""},{"location":"faq/#how-do-i-create-a-simple-event-handler","title":"How do I create a simple event handler?","text":"<pre><code>from minevent import EventHandler, EventManager\n\n\ndef my_handler():\n    print(\"Event triggered!\")\n\n\nmanager = EventManager()\nmanager.add_event_handler(\"my_event\", EventHandler(my_handler))\nmanager.trigger_event(\"my_event\")\n</code></pre>"},{"location":"faq/#can-i-pass-arguments-to-event-handlers","title":"Can I pass arguments to event handlers?","text":"<p>Yes, use <code>handler_args</code> and <code>handler_kwargs</code>:</p> <pre><code>from minevent import EventHandler\n\n\ndef greet(name: str, greeting: str = \"Hello\"):\n    print(f\"{greeting}, {name}!\")\n\n\nhandler = EventHandler(\n    greet, handler_args=(\"Alice\",), handler_kwargs={\"greeting\": \"Hi\"}\n)\nhandler.handle()  # Prints: Hi, Alice!\n</code></pre>"},{"location":"faq/#how-do-i-execute-a-handler-only-sometimes","title":"How do I execute a handler only sometimes?","text":"<p>Use <code>ConditionalEventHandler</code> with a condition:</p> <pre><code>from minevent import ConditionalEventHandler, PeriodicCondition\n\n# Execute only every 5 times\nhandler = ConditionalEventHandler(my_function, PeriodicCondition(freq=5))\n</code></pre>"},{"location":"faq/#can-i-add-the-same-handler-to-multiple-events","title":"Can I add the same handler to multiple events?","text":"<p>Yes! You can register the same handler to different events:</p> <pre><code>handler = EventHandler(my_function)\nmanager.add_event_handler(\"event1\", handler)\nmanager.add_event_handler(\"event2\", handler)\n</code></pre>"},{"location":"faq/#how-do-i-remove-an-event-handler","title":"How do I remove an event handler?","text":"<p>Use the <code>remove_event_handler</code> method:</p> <pre><code>manager.remove_event_handler(\"my_event\", handler)\n</code></pre>"},{"location":"faq/#what-happens-if-i-trigger-an-event-with-no-handlers","title":"What happens if I trigger an event with no handlers?","text":"<p>Nothing! The <code>trigger_event</code> method safely handles events with no registered handlers - it simply does nothing and updates the last triggered event name.</p>"},{"location":"faq/#can-i-check-if-a-handler-is-already-registered","title":"Can I check if a handler is already registered?","text":"<p>Yes, use <code>has_event_handler</code>:</p> <pre><code>if not manager.has_event_handler(handler, \"my_event\"):\n    manager.add_event_handler(\"my_event\", handler)\n</code></pre>"},{"location":"faq/#are-event-handlers-executed-in-order","title":"Are event handlers executed in order?","text":"<p>Yes! Event handlers are executed in the order they were registered using <code>add_event_handler</code>.</p>"},{"location":"faq/#is-minevent-thread-safe","title":"Is minevent thread-safe?","text":"<p>No, <code>minevent</code> is not thread-safe by design. It is intended for synchronous, single-threaded use cases. If you need thread-safe event handling, consider using locks or other synchronization mechanisms.</p>"},{"location":"faq/#advanced-questions","title":"Advanced Questions","text":""},{"location":"faq/#can-i-create-custom-conditions","title":"Can I create custom conditions?","text":"<p>Yes! Implement the <code>BaseCondition</code> class:</p> <pre><code>from minevent.conditions import BaseCondition\n\n\nclass MyCondition(BaseCondition):\n    def evaluate(self) -&gt; bool:\n        # Your custom logic here\n        return some_condition\n\n    def equal(self, other) -&gt; bool:\n        return isinstance(other, MyCondition)\n</code></pre>"},{"location":"faq/#can-i-create-custom-event-handlers","title":"Can I create custom event handlers?","text":"<p>Yes! Implement the <code>BaseEventHandler</code> class:</p> <pre><code>from minevent.handlers import BaseEventHandler\n\n\nclass MyEventHandler(BaseEventHandler):\n    def handle(self) -&gt; None:\n        # Your custom logic here\n        pass\n\n    def equal(self, other) -&gt; bool:\n        return isinstance(other, MyEventHandler)\n</code></pre>"},{"location":"faq/#how-do-i-integrate-minevent-into-my-training-loop","title":"How do I integrate minevent into my training loop?","text":"<p>Here's a common pattern for ML training:</p> <pre><code>from minevent import EventManager, EventHandler\n\n\ndef train(epochs, manager):\n    manager.trigger_event(\"training_start\")\n\n    for epoch in range(epochs):\n        manager.trigger_event(\"epoch_start\")\n\n        # Training logic here\n        for batch in data_loader:\n            manager.trigger_event(\"batch_start\")\n            # Process batch\n            manager.trigger_event(\"batch_end\")\n\n        manager.trigger_event(\"epoch_end\")\n\n    manager.trigger_event(\"training_end\")\n\n\n# Setup handlers\nmanager = EventManager()\nmanager.add_event_handler(\"epoch_end\", EventHandler(save_checkpoint))\nmanager.add_event_handler(\"training_end\", EventHandler(log_metrics))\n\ntrain(epochs=10, manager=manager)\n</code></pre>"},{"location":"faq/#can-event-handlers-modify-the-event-manager","title":"Can event handlers modify the event manager?","text":"<p>Yes, but be cautious! An event handler can add or remove other handlers, but modifying the handlers of the currently firing event during its execution is not recommended as it may lead to unexpected behavior.</p>"},{"location":"faq/#what-is-the-performance-overhead-of-using-minevent","title":"What is the performance overhead of using minevent?","text":"<p><code>minevent</code> is designed to be lightweight with minimal overhead. The main cost is the function call overhead for each registered handler. For most ML workflows, this overhead is negligible compared to the computation time of training operations.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq/#i-get-runtimeerror-event-does-not-exist-when-removing-a-handler","title":"I get \"RuntimeError: event does not exist\" when removing a handler","text":"<p>This means you're trying to remove a handler from an event that hasn't been registered. Make sure:</p> <ol> <li>The event name matches exactly (event names are case-sensitive)</li> <li>At least one handler has been added to that event before trying to remove one</li> </ol>"},{"location":"faq/#my-handler-isnt-being-called","title":"My handler isn't being called","text":"<p>Check that:</p> <ol> <li>You've registered the handler with <code>add_event_handler</code></li> <li>You're triggering the correct event name (case-sensitive)</li> <li>If using <code>ConditionalEventHandler</code>, the condition evaluates to <code>True</code></li> <li>The handler function is callable and doesn't raise exceptions</li> </ol>"},{"location":"faq/#how-do-i-debug-event-handlers","title":"How do I debug event handlers?","text":"<p>Add logging to your handlers:</p> <pre><code>import logging\n\n\ndef my_handler():\n    logging.info(\"Handler called\")\n    # Your logic here\n</code></pre> <p>Or check the event manager state:</p> <pre><code>print(manager)  # Shows all registered handlers\nprint(manager.last_triggered_event)  # Shows last triggered event\n</code></pre>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#where-can-i-report-bugs-or-request-features","title":"Where can I report bugs or request features?","text":"<p>Please use the GitHub issue tracker to report bugs or request features.</p>"},{"location":"faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>See the Contributing Guide for information on how to contribute to <code>minevent</code>.</p>"},{"location":"faq/#where-can-i-find-more-examples","title":"Where can I find more examples?","text":"<p>Check the quickstart guide and the examples in the <code>examples/</code> directory of the repository.</p>"},{"location":"get_started/","title":"Get Started","text":"<p>It is highly recommended to install in a virtual environment to keep your system in order.</p>"},{"location":"get_started/#installing-with-pip-recommended","title":"Installing with <code>pip</code> (recommended)","text":"<p>We highly recommend installing a virtual environment. <code>minevent</code> can be installed from pip using the following command:</p> <pre><code>pip install minevent\n</code></pre> <p>To make the package as slim as possible, only the minimal packages required to use <code>minevent</code> are installed. To include all the dependencies, you can use the following command:</p> <pre><code>pip install minevent[all]\n</code></pre>"},{"location":"get_started/#installing-from-source","title":"Installing from source","text":"<p>To install <code>minevent</code> from source, you can follow the steps below.</p>"},{"location":"get_started/#prerequisites","title":"Prerequisites","text":"<p>This project uses <code>uv</code> for dependency management. If you don't have <code>uv</code> installed, you can install it by following the official installation guide.</p>"},{"location":"get_started/#clone-the-repository","title":"Clone the repository","text":"<p>First, clone the git repository:</p> <pre><code>git clone git@github.com:durandtibo/minevent.git\ncd minevent\n</code></pre>"},{"location":"get_started/#create-a-virtual-environment-optional-but-recommended","title":"Create a virtual environment (optional but recommended)","text":"<p>It is recommended to create a Python 3.10+ virtual environment. You can use <code>uv</code> to create a virtual environment:</p> <pre><code>uv venv --python 3.13\nsource .venv/bin/activate\n</code></pre>"},{"location":"get_started/#install-dependencies","title":"Install dependencies","text":"<p>Once you have activated your virtual environment, install the required packages with:</p> <pre><code>inv install\n</code></pre> <p>Or if you're developing and need documentation dependencies:</p> <pre><code>inv install --docs-deps\n</code></pre> <p>These commands will install all the required packages. You can also use these commands to update the required packages.</p>"},{"location":"get_started/#verify-the-installation","title":"Verify the installation","text":"<p>Finally, you can test the installation by running the test suite:</p> <pre><code>inv unit-test --cov\n</code></pre>"},{"location":"get_started/#development-workflow","title":"Development workflow","text":"<p>If you're planning to contribute to <code>minevent</code>, please refer to the Contributing Guide for more information on setting up your development environment and running tests.</p>"},{"location":"quickstart/","title":"quickstart","text":""},{"location":"quickstart/#overview","title":"Overview","text":"<p>The <code>minevent</code> event system is composed of three main components:</p> <ul> <li>an event</li> <li>an event handler</li> <li>an event manager</li> </ul> <p>It is a synchronous system i.e. only one event and event handler are executed at the same time. This page presents the design used in <code>minevent</code>, but other designs exist. The proposed design was not designed to work in all the scenarios, so it is highly recommended to read the documentation to understand if it fits your needs/requirements before to use it.</p>"},{"location":"quickstart/#event","title":"Event","text":"<p>In <code>minevent</code>, an event is a string that represents something happening. The event is represented by the event name. For example, it is possible to write the following line to define an event that happens after the training is completed.</p> <pre><code>my_event = \"training completed\"\n</code></pre>"},{"location":"quickstart/#event-handler","title":"Event handler","text":"<p>In <code>minevent</code>, an event handler is a piece a code that is executed when an even happened.</p> <p>An event handler must have two methods:</p> <ul> <li><code>handle</code> which executes a piece of code when the event happens.</li> <li><code>equal</code> which is used to compare two event handlers.</li> </ul> <p><code>minevent</code> provides two event handlers:</p> <ul> <li><code>EventHandler</code> which is a simple event handler</li> <li><code>ConditionalEventHandler</code> which is an extension of <code>EventHandler</code> to execute the logic only when a   condition is true.</li> </ul>"},{"location":"quickstart/#basic-event-handler","title":"Basic event handler","text":"<p>Let's assume we want to create an event handler to say hello when an event is fired. It is possible to implement this scenario as follow by using <code>minvent.EventHandler</code>.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"quickstart/#event-handler-with-arguments","title":"Event handler with arguments","text":"<p>The previous example has no arguments. It is also possible to provide some arguments to customize the event handler. The arguments can be given as positional arguments using <code>handler_args</code>:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler(name: str, day: str) -&gt; None:\n...     print(f\"Hello {name}! Happy {day}!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler, handler_args=(\"Bob\", \"Monday\"))\n&gt;&gt;&gt; handler.handle()\nHello Bob! Happy Monday!\n</code></pre> <p>It is also possible to give the arguments as keyword arguments using <code>handler_kwargs</code>:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler(name: str, day: str) -&gt; None:\n...     print(f\"Hello {name}! Happy {day}!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler, handler_kwargs={\"name\": \"Bob\", \"day\": \"Monday\"})\n&gt;&gt;&gt; handler.handle()\nHello Bob! Happy Monday!\n</code></pre> <p>It is also possible to use <code>handler_args</code> and <code>handler_kwargs</code>:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler(name: str, day: str) -&gt; None:\n...     print(f\"Hello {name}! Happy {day}!\")\n...\n&gt;&gt;&gt; handler = EventHandler(\n...     hello_handler, handler_args=[\"Bob\"], handler_kwargs={\"day\": \"Monday\"}\n... )\n&gt;&gt;&gt; handler.handle()\nHello Bob! Happy Monday!\n</code></pre> <p>It is possible to define event handlers with a large range of functions. For example, it is possible to implement the same logic by using directly <code>print</code>:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; handler = EventHandler(print, handler_args=(\"Hello Bob! Happy Monday!\",))\n&gt;&gt;&gt; handler.handle()\nHello Bob! Happy Monday!\n</code></pre>"},{"location":"quickstart/#event-handler-with-condition","title":"Event handler with condition","text":"<p>It is possible to define an event handler that is executed when a condition is true. The following example shows how to define an event handler where the logic is executed every three calls.</p> <pre><code>&gt;&gt;&gt; from minevent import ConditionalEventHandler, PeriodicCondition\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre> <p><code>PeriodicCondition</code> is a condition implemented in <code>minevent</code> to execute an event handler with a periodic pattern. It is also possible to implement custom conditions. If the condition returns <code>True</code>, the logic associated to the event handler is executed, otherwise the logic associated to the event handler is not executed.</p>"},{"location":"quickstart/#event-handler-comparison","title":"Event handler comparison","text":"<p>It is possible to compare event handlers by using the <code>equal</code> method. Two <code>EventHandler</code>s are equal if they have the same handler and the same arguments:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.equal(EventHandler(hello_handler))\nTrue\n&gt;&gt;&gt; handler.equal(EventHandler(print, handler_args=(\"Hello Bob! Happy Monday!\",)))\nFalse\n</code></pre> <p>Two <code>EventHandler</code>s are equal if they have the same handler, the same arguments and the same condition:</p> <pre><code>&gt;&gt;&gt; from minevent import ConditionalEventHandler, PeriodicCondition\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n&gt;&gt;&gt; handler.equal(ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3)))\nTrue\n&gt;&gt;&gt; handler.equal(ConditionalEventHandler(hello_handler, PeriodicCondition(freq=2)))\nFalse\n</code></pre>"},{"location":"quickstart/#event-manager","title":"Event manager","text":"<ul> <li>Overview of the event manager</li> <li>Create an event manager</li> <li>Add an event handler</li> <li>Check the presence of an event handler</li> <li>Fire an event</li> <li>Remove an event handler</li> <li>Reset the event manager</li> <li>Internals</li> </ul>"},{"location":"quickstart/#overview-of-the-event-manager","title":"Overview of the event manager","text":"<p>As explained by its name, the goal of the event manager is to manage event handlers. The event manager supports the following functionalities:</p> <ul> <li>adding an event handler</li> <li>firing all the event handlers associated to an event.</li> <li>removing an event handler from an event</li> </ul>"},{"location":"quickstart/#create-an-event-manager","title":"Create an event manager","text":"<p>To use the event system, it is important to create an event manager. <code>minevent</code> implements an event manager, but it is possible to implement and use other compatible event managers. This documentation uses the default event manager implemented in <code>minevent</code>. To create an event manager, you can write:</p> <pre><code>&gt;&gt;&gt; from minevent import EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n  (last_triggered_event): None\n)\n</code></pre> <p>The main pieces of information about the experiment manager state are the list of event handlers for each event name, and the last fired event name. The event manager is empty, so it shows there is no event handler. In this example, there was no event fired so the last fired event name is <code>None</code>.</p>"},{"location":"quickstart/#add-an-event-handler","title":"Add an event handler","text":"<p>This section describes how to add an event handler to an event manager. The method to add an event handler to the event manager is <code>add_event_handler</code>. There are several approaches to add an event handler.</p> <p>The simplest approach requires an event and an event handler. The following example shows how to add a <code>hello_handler</code> handler to the <code>'my_event'</code> event.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n        (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n</code></pre> <p>You can see there is a registered event handler for the event name <code>my_event</code>.</p> <p>It is possible to add an event handler that takes some input arguments. The following example shows how to add an event handler with some positional arguments.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler(first_name: str, last_name: str) -&gt; None:\n...     print(f\"Hello. I am {last_name}, {first_name} {last_name}\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler, (\"John\", \"Smith\")))\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler, (\"Jane\", \"Doe\")))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ('John', 'Smith')\n          (handler_kwargs): {}\n        )\n      (1): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ('Jane', 'Doe')\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n</code></pre> <p>For a given event, the event handlers are ordered by using the order of addition. The event handler <code>(0)</code> was added before the event handler <code>(1)</code>. Internally, each event uses a list to store the registered event handlers. It is possible to add the same event handler multiple times:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n      (1): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n</code></pre>"},{"location":"quickstart/#check-the-presence-of-an-event-handler","title":"Check the presence of an event handler","text":"<p>It is possible to check if an event handler is in the event manager by using the <code>has_event_handler</code> method. Sometimes, it may be important to check if an event handler is not already added before to add it. The following code shows how to check if the <code>hello_handler</code> handler is registered at least one time in the event manager:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nFalse\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nTrue\n</code></pre> <p>Note that it is not necessary to specify an event. If no event is specified, this method checks if the handler is present in any of the events. It is possible to specify an event to check if a handler is registered for a given event. The following code shows how to check if the <code>hello_handler</code> handler is registered for the <code>'my_event'</code> event:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_other_event\")\nFalse\n</code></pre> <p>If you want to add an event handler only once, you can write something like:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; for _ in range(5):\n...     if not manager.has_event_handler(EventHandler(hello_handler), \"my_event\"):\n...         manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n...\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n</code></pre> <p>The <code>hello_handler</code> handler has been added only one time to the <code>'my_event'</code> event.</p>"},{"location":"quickstart/#fire-an-event","title":"Fire an event","text":"<p>This section describes how to fire an event. As explained above, it is possible to add a handler to an event. Then, we want to execute the handler when the event is fired. The following example shows how to fire the <code>hello_handler</code> for the event <code>'my_event'</code>:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): my_event\n)\n</code></pre> <p>You can note that the last fired event name has been updated. The current last fired event name is <code>'my_event'</code>. The event manager uses the arguments that were given when the event handler was added.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler(first_name: str, last_name: str) -&gt; None:\n...     print(f\"Hello. I am {first_name} {last_name}\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler, (\"John\", \"Smith\")))\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler, (\"Jane\", \"Doe\")))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ('John', 'Smith')\n          (handler_kwargs): {}\n        )\n      (1): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ('Jane', 'Doe')\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello. I am John Smith\nHello. I am Jane Doe\n</code></pre> <p>As explained above, it is possible to add a condition to control when to execute the handler. The following shows how to execute the <code>hello_handler</code> every 3 <code>'my_event'</code> events.</p> <pre><code>&gt;&gt;&gt; from minevent import ConditionalEventHandler, PeriodicCondition, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\n...     \"my_event\", ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n... )\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): ConditionalEventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n          (condition): PeriodicCondition(freq=3, step=0)\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; for i in range(10):\n...     print(f\"i={i}\")\n...     manager.trigger_event(\"my_event\")\n...\ni=0\nHello!\ni=1\ni=2\ni=3\nHello!\ni=4\ni=5\ni=6\nHello!\ni=7\ni=8\ni=9\nHello!\n</code></pre> <p>The <code>trigger_event</code> method does nothing if there is no event handler registered for the event:</p> <pre><code>&gt;&gt;&gt; from minevent import EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\n</code></pre>"},{"location":"quickstart/#remove-an-event-handler","title":"Remove an event handler","text":"<p>A previous section describes how to add an event handler, but sometimes it is useful to remove an event handler. The method <code>remove_event_handler</code> allows to remove an event handler from the event manager. As explained above, the event handler is identified by an event name and a handler. The following example shows how to add and remove an event handler:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n        (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.remove_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n  (last_triggered_event): None\n)\n</code></pre> <p>If there are multiple event handlers that match, they are all removed from the event manager:</p> <pre><code>&gt;&gt;&gt; from minevent import (\n...     ConditionalEventHandler,\n...     PeriodicCondition,\n...     EventHandler,\n...     EventManager,\n... )\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.add_event_handler(\n...     \"my_event\", ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n... )\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n      (1): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n      (2): ConditionalEventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n          (condition): PeriodicCondition(freq=3, step=0)\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.remove_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): ConditionalEventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n          (condition): PeriodicCondition(freq=3, step=0)\n        )\n  (last_triggered_event): None\n)\n</code></pre> <p>If a handler is used for multiple events, only the handler associated to the event are removed:</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.add_event_handler(\"my_other_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n    (my_other_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.remove_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_other_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at  0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n</code></pre> <p>A <code>RuntimeError</code> exception is raised if you try to remove an event handler that does not exist.</p>"},{"location":"quickstart/#reset-the-event-manager","title":"Reset the event manager","text":"<p>It is possible to reset the event manager with the <code>reset</code> method. It removes all the event handlers and set the last fired event name to <code>None</code>. It is equivalent to create a new experiment manager.</p> <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.add_event_handler(\"my_other_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n    (my_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at 0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n    (my_other_event):\n      (0): EventHandler(\n          (handler): &lt;function hello_handler at 0x...&gt;\n          (handler_args): ()\n          (handler_kwargs): {}\n        )\n  (last_triggered_event): None\n)\n&gt;&gt;&gt; manager.reset()\n&gt;&gt;&gt; manager\nEventManager(\n  (event_handlers):\n  (last_triggered_event): None\n)\n</code></pre>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This guide helps you diagnose and resolve common issues when using <code>minevent</code>.</p>"},{"location":"troubleshooting/#common-issues","title":"Common Issues","text":""},{"location":"troubleshooting/#event-handler-not-executing","title":"Event Handler Not Executing","text":"<p>Symptoms: You trigger an event but the handler doesn't execute.</p> <p>Possible Causes and Solutions:</p> <ol> <li>Handler not registered</li> </ol> <pre><code># Check if handler is registered\nhandler = EventHandler(my_function)\nif not manager.has_event_handler(handler, \"my_event\"):\n    print(\"Handler not registered!\")\n    manager.add_event_handler(\"my_event\", handler)\n</code></pre> <ol> <li>Wrong event name (event names are case-sensitive)</li> </ol> <pre><code># These are different events!\nmanager.add_event_handler(\"MyEvent\", handler)\nmanager.trigger_event(\"myevent\")  # Won't trigger - different case!\n\n# Solution: Use consistent naming\nEVENT_NAME = \"my_event\"\nmanager.add_event_handler(EVENT_NAME, handler)\nmanager.trigger_event(EVENT_NAME)\n</code></pre> <ol> <li>Conditional handler condition is False</li> </ol> <pre><code># Check condition state\ncondition = PeriodicCondition(freq=5)\nhandler = ConditionalEventHandler(my_function, condition)\n\n# The handler only executes every 5 calls\nfor i in range(10):\n    manager.trigger_event(\"my_event\")\n    print(f\"Call {i}: Condition evaluated to {condition.evaluate()}\")\n</code></pre> <ol> <li>Handler raises an exception</li> </ol> <pre><code># Add error handling to debug\ndef safe_handler():\n    try:\n        my_function()\n    except Exception as e:\n        print(f\"Handler error: {e}\")\n        import traceback\n\n        traceback.print_exc()\n\n\nmanager.add_event_handler(\"my_event\", EventHandler(safe_handler))\n</code></pre>"},{"location":"troubleshooting/#runtimeerror-event-does-not-exist","title":"RuntimeError: Event Does Not Exist","text":"<p>Symptoms: <code>RuntimeError: 'event_name' event does not exist</code> when trying to remove a handler.</p> <p>Cause: You're trying to remove a handler from an event that has no registered handlers.</p> <p>Solution:</p> <pre><code># Check if event has handlers before removing\nif manager.has_event_handler(handler):\n    try:\n        manager.remove_event_handler(\"my_event\", handler)\n    except RuntimeError as e:\n        print(f\"Could not remove handler: {e}\")\n</code></pre>"},{"location":"troubleshooting/#runtimeerror-handler-not-found","title":"RuntimeError: Handler Not Found","text":"<p>Symptoms: Error when trying to remove a handler that doesn't exist for that event.</p> <p>Cause: The handler was never added, or it was already removed.</p> <p>Solution:</p> <pre><code># Verify handler exists before removal\nhandler = EventHandler(my_function)\nif manager.has_event_handler(handler, \"my_event\"):\n    manager.remove_event_handler(\"my_event\", handler)\nelse:\n    print(\"Handler not registered for this event\")\n</code></pre>"},{"location":"troubleshooting/#handler-comparison-issues","title":"Handler Comparison Issues","text":"<p>Symptoms: <code>has_event_handler</code> returns <code>False</code> even though you added the handler.</p> <p>Cause: Handler comparison uses the <code>equal</code> method, which compares handler functions and arguments.</p> <p>Solution:</p> <pre><code># These are considered DIFFERENT handlers\nhandler1 = EventHandler(my_function, handler_args=(1,))\nhandler2 = EventHandler(my_function, handler_args=(2,))  # Different args\nprint(handler1.equal(handler2))  # False\n\n# These are considered EQUAL\nhandler3 = EventHandler(my_function, handler_args=(1,))\nhandler4 = EventHandler(my_function, handler_args=(1,))  # Same args\nprint(handler3.equal(handler4))  # True\n\n# Solution: Keep reference to original handler\noriginal_handler = EventHandler(my_function, handler_args=(1,))\nmanager.add_event_handler(\"event\", original_handler)\n# Later...\nmanager.has_event_handler(original_handler, \"event\")  # True\n</code></pre>"},{"location":"troubleshooting/#memory-leaks","title":"Memory Leaks","text":"<p>Symptoms: Memory usage grows over time in long-running applications.</p> <p>Cause: Event handlers holding references to large objects or not being cleaned up.</p> <p>Solution:</p> <pre><code># Clear handlers when done\ndef cleanup():\n    manager.reset()  # Removes all handlers\n\n\n# Use weak references for large objects\nimport weakref\n\n\nclass MyHandler:\n    def __init__(self, large_object):\n        self._large_object_ref = weakref.ref(large_object)\n\n    def handle(self):\n        obj = self._large_object_ref()\n        if obj is not None:\n            # Use object\n            pass\n</code></pre>"},{"location":"troubleshooting/#unexpected-handler-execution-order","title":"Unexpected Handler Execution Order","text":"<p>Symptoms: Handlers execute in unexpected order.</p> <p>Cause: Handlers execute in the order they were registered.</p> <p>Solution:</p> <pre><code># Handlers execute in registration order\nmanager.add_event_handler(\"event\", EventHandler(first_handler))  # Executes 1st\nmanager.add_event_handler(\"event\", EventHandler(second_handler))  # Executes 2nd\nmanager.add_event_handler(\"event\", EventHandler(third_handler))  # Executes 3rd\n\n\n# If order matters, register in correct order\n# Or use a single handler that calls functions in desired order\ndef orchestrator():\n    first_handler()\n    second_handler()\n    third_handler()\n\n\nmanager.add_event_handler(\"event\", EventHandler(orchestrator))\n</code></pre>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#slow-event-triggering","title":"Slow Event Triggering","text":"<p>Symptoms: <code>trigger_event</code> takes a long time.</p> <p>Possible Causes:</p> <ol> <li>Too many handlers registered</li> </ol> <pre><code># Check number of handlers\nprint(f\"Manager state: {manager}\")\n\n\n# Reduce handlers by combining related operations\ndef combined_handler():\n    operation1()\n    operation2()\n    operation3()\n\n\nmanager.add_event_handler(\"event\", EventHandler(combined_handler))\n</code></pre> <ol> <li>Handlers performing heavy computation</li> </ol> <pre><code># Profile handler execution time\nimport time\n\n\ndef timed_handler():\n    start = time.time()\n    actual_handler()\n    elapsed = time.time() - start\n    if elapsed &gt; 0.1:\n        print(f\"Handler took {elapsed:.2f}s\")\n\n\n# Move heavy work to background thread\nimport concurrent.futures\n\nexecutor = concurrent.futures.ThreadPoolExecutor()\n\n\ndef async_handler():\n    executor.submit(heavy_computation)\n\n\nmanager.add_event_handler(\"event\", EventHandler(async_handler))\n</code></pre> <ol> <li>Frequent condition evaluation</li> </ol> <pre><code># Use PeriodicCondition to reduce execution frequency\nfrom minevent import ConditionalEventHandler, PeriodicCondition\n\n# Instead of executing every time\nmanager.add_event_handler(\"frequent_event\", EventHandler(expensive_handler))\n\n# Execute less frequently\nmanager.add_event_handler(\n    \"frequent_event\",\n    ConditionalEventHandler(expensive_handler, PeriodicCondition(freq=10)),\n)\n</code></pre>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#enable-logging","title":"Enable Logging","text":"<pre><code>import logging\n\n# Enable debug logging for minevent\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(\"minevent\")\nlogger.setLevel(logging.DEBUG)\n\n# Now minevent will log when handlers are added/removed/triggered\nmanager = EventManager()\nmanager.add_event_handler(\"event\", EventHandler(my_handler))\nmanager.trigger_event(\"event\")\n</code></pre>"},{"location":"troubleshooting/#inspect-event-manager-state","title":"Inspect Event Manager State","text":"<pre><code># Print manager state to see all registered handlers\nprint(manager)\n\n# Check last triggered event\nprint(f\"Last event: {manager.last_triggered_event}\")\n\n# Check if specific handler is registered\nhandler = EventHandler(my_function)\nprint(f\"Handler registered: {manager.has_event_handler(handler)}\")\nprint(f\"Handler registered for 'event': {manager.has_event_handler(handler, 'event')}\")\n</code></pre>"},{"location":"troubleshooting/#add-debugging-handlers","title":"Add Debugging Handlers","text":"<pre><code># Add a debug handler that logs all events\ndef debug_handler(event_name):\n    print(f\"DEBUG: Event '{event_name}' triggered\")\n\n\n# Register for multiple events\nfor event in [\"event1\", \"event2\", \"event3\"]:\n    manager.add_event_handler(event, EventHandler(debug_handler, handler_args=(event,)))\n</code></pre>"},{"location":"troubleshooting/#testing-issues","title":"Testing Issues","text":""},{"location":"troubleshooting/#handlers-not-called-in-tests","title":"Handlers Not Called in Tests","text":"<p>Cause: Event manager not properly set up in test fixtures.</p> <p>Solution:</p> <pre><code>import pytest\nfrom minevent import EventManager, EventHandler\n\n\n@pytest.fixture\ndef manager():\n    \"\"\"Create a fresh event manager for each test.\"\"\"\n    mgr = EventManager()\n    yield mgr\n    mgr.reset()  # Clean up after test\n\n\ndef test_handler_execution(manager):\n    \"\"\"Test that handler is called.\"\"\"\n    called = []\n\n    def test_handler():\n        called.append(True)\n\n    manager.add_event_handler(\"test_event\", EventHandler(test_handler))\n    manager.trigger_event(\"test_event\")\n\n    assert len(called) == 1\n</code></pre>"},{"location":"troubleshooting/#mocking-handlers","title":"Mocking Handlers","text":"<pre><code>from unittest.mock import Mock\n\n\ndef test_with_mock():\n    \"\"\"Test using mock handlers.\"\"\"\n    manager = EventManager()\n    mock_handler = Mock()\n\n    manager.add_event_handler(\"event\", EventHandler(mock_handler))\n    manager.trigger_event(\"event\")\n\n    mock_handler.assert_called_once()\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still experiencing issues:</p> <ol> <li>Check the FAQ: See FAQ for common questions 2Search Issues: Check    existing issues on GitHub 3Ask for Help: Open a    new issue with:<ul> <li>Your <code>minevent</code> version</li> <li>Python version</li> <li>Minimal code to reproduce the problem</li> <li>Full error message and stack trace</li> <li>What you've tried so far</li> </ul> </li> </ol>"},{"location":"troubleshooting/#reporting-bugs","title":"Reporting Bugs","text":"<p>When reporting bugs, please include:</p> <ol> <li> <p>Environment Information:    <pre><code>import minevent\nimport sys\n\nprint(f\"minevent version: {minevent.__version__}\")\nprint(f\"Python version: {sys.version}\")\n</code></pre></p> </li> <li> <p>Minimal Reproducible Example: Simplest code that reproduces the issue</p> </li> <li> <p>Expected vs Actual Behavior: What you expected to happen vs what actually happened</p> </li> <li> <p>Stack Trace: Full error message if applicable</p> </li> <li> <p>Steps to Reproduce: Clear steps to reproduce the issue</p> </li> </ol>"},{"location":"refs/","title":"Main classes and functions","text":""},{"location":"refs/#minevent","title":"minevent","text":"<p>Contain the main features of the <code>minevent</code> package.</p>"},{"location":"refs/#minevent.BaseCondition","title":"minevent.BaseCondition","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a condition for <code>ConditionalEventHandler</code>.</p> <p>A child class has to implement the following methods:</p> <pre><code>- ``evaluate``\n- ``equal``\n</code></pre> Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n</code></pre>"},{"location":"refs/#minevent.BaseCondition.equal","title":"minevent.BaseCondition.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Compare two conditions for equality.</p> <p>This method should be implemented by child classes to define how conditions are compared. This is used when comparing conditional event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with. Can be any type, though typically a condition.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two conditions are considered equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.equal(PeriodicCondition(freq=3))\nTrue\n&gt;&gt;&gt; condition.equal(PeriodicCondition(freq=2))\nFalse\n</code></pre>"},{"location":"refs/#minevent.BaseCondition.evaluate","title":"minevent.BaseCondition.evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate() -&gt; bool\n</code></pre> <p>Evaluate the condition given the current state.</p> <p>This method should be implemented by child classes to define the logic for determining whether a conditional event handler should be executed. The method is called without arguments and may maintain internal state between calls.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the condition is satisfied and the event handler logic should be executed, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.BaseEventHandler","title":"minevent.BaseEventHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an event handler.</p> <p>A child class has to implement the following methods:</p> <pre><code>- ``handle``\n- ``equal``\n</code></pre> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.BaseEventHandler.equal","title":"minevent.BaseEventHandler.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Compare two event handlers for equality.</p> <p>This method should be implemented by child classes to define how event handlers are compared. This is used by the event manager to check for duplicate handlers.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with. Can be any type, though typically an event handler.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two event handlers are considered equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.equal(EventHandler(hello_handler))\nTrue\n&gt;&gt;&gt; handler.equal(EventHandler(print, handler_args=[\"Hello!\"]))\nFalse\n</code></pre>"},{"location":"refs/#minevent.BaseEventHandler.handle","title":"minevent.BaseEventHandler.handle  <code>abstractmethod</code>","text":"<pre><code>handle() -&gt; None\n</code></pre> <p>Handle the event.</p> <p>This method executes the logic associated with the event handler. It should be implemented by child classes to define the specific behavior when an event is triggered.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.BaseEventHandlerWithArguments","title":"minevent.BaseEventHandlerWithArguments","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Define a base class to implement an event handler with positional and/or keyword arguments.</p> <p>A child class has to implement the <code>equal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>The callable function or method to be invoked when the event is triggered.</p> required <code>handler_args</code> <code>Sequence[Any] | None</code> <p>The positional arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> <code>handler_kwargs</code> <code>dict[str, Any] | None</code> <p>The keyword arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler = EventHandler(print, handler_args=[\"Hello!\"])\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.BaseEventHandlerWithArguments.handler","title":"minevent.BaseEventHandlerWithArguments.handler  <code>property</code>","text":"<pre><code>handler: Callable\n</code></pre> <p>Get the handler function.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>The handler function that will be called when the event is triggered.</p>"},{"location":"refs/#minevent.BaseEventHandlerWithArguments.handler_args","title":"minevent.BaseEventHandlerWithArguments.handler_args  <code>property</code>","text":"<pre><code>handler_args: tuple[Any]\n</code></pre> <p>Get the positional arguments for the handler.</p> <p>Returns:</p> Type Description <code>tuple[Any]</code> <p>A tuple containing the positional arguments that will be passed to the handler when it is called.</p>"},{"location":"refs/#minevent.BaseEventHandlerWithArguments.handler_kwargs","title":"minevent.BaseEventHandlerWithArguments.handler_kwargs  <code>property</code>","text":"<pre><code>handler_kwargs: dict[str, Any]\n</code></pre> <p>Get the keyword arguments for the handler.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the keyword arguments that will be passed to the handler when it is called.</p>"},{"location":"refs/#minevent.ConditionalEventHandler","title":"minevent.ConditionalEventHandler","text":"<p>               Bases: <code>BaseEventHandlerWithArguments</code></p> <p>Implement a conditional event handler.</p> <p>This class extends <code>BaseEventHandlerWithArguments</code> to add conditional execution. The handler is executed only if the associated condition evaluates to <code>True</code>. This is useful for scenarios where event handlers should only run under specific circumstances, such as periodic execution or state-based triggering.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>The callable function or method to be invoked when the event is triggered and the condition is <code>True</code>.</p> required <code>condition</code> <code>BaseCondition</code> <p>The condition object that controls whether the handler is executed. The condition's <code>evaluate</code> method is called without arguments and must return a boolean value.</p> required <code>handler_args</code> <code>Sequence[Any] | None</code> <p>The positional arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> <code>handler_kwargs</code> <code>dict[str, Any] | None</code> <p>The keyword arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import ConditionalEventHandler, PeriodicCondition\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n&gt;&gt;&gt; handler\nConditionalEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n  (condition): PeriodicCondition(freq=3, step=0)\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.ConditionalEventHandler.condition","title":"minevent.ConditionalEventHandler.condition  <code>property</code>","text":"<pre><code>condition: BaseCondition\n</code></pre> <p>Get the condition that controls handler execution.</p> <p>Returns:</p> Type Description <code>BaseCondition</code> <p>The condition that must evaluate to <code>True</code> for the handler to be executed.</p>"},{"location":"refs/#minevent.EventHandler","title":"minevent.EventHandler","text":"<p>               Bases: <code>BaseEventHandlerWithArguments</code></p> <p>Implement a simple event handler.</p> <p>This class wraps a callable function or method and allows it to be executed as an event handler. The handler can be configured with positional and keyword arguments that will be passed when the handler is executed.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/#minevent.EventManager","title":"minevent.EventManager","text":"<p>Implement an event manager.</p> <p>This event manager allows registering event handlers and triggering events. An event is represented by a case-sensitive string. Each event can have multiple handlers attached, and all handlers are executed in the order they were added when the event is triggered. The manager also tracks the last triggered event.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n</code></pre>"},{"location":"refs/#minevent.EventManager.last_triggered_event","title":"minevent.EventManager.last_triggered_event  <code>property</code>","text":"<pre><code>last_triggered_event: str | None\n</code></pre> <p>Get the last event name that was triggered.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The last event name that was fired of <code>None</code> if no event was fired.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n&gt;&gt;&gt; manager.last_triggered_event\n</code></pre>"},{"location":"refs/#minevent.EventManager.add_event_handler","title":"minevent.EventManager.add_event_handler","text":"<pre><code>add_event_handler(\n    event: str, event_handler: BaseEventHandler\n) -&gt; None\n</code></pre> <p>Add an event handler to an event.</p> <p>The event handler will be called every time the specified event is triggered. Multiple handlers can be registered to the same event, and they will be executed in the order they were added.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) to which the event handler should be attached.</p> required <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to attach to the event.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import EventManager, EventHandler\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n</code></pre>"},{"location":"refs/#minevent.EventManager.has_event_handler","title":"minevent.EventManager.has_event_handler","text":"<pre><code>has_event_handler(\n    event_handler: BaseEventHandler,\n    event: str | None = None,\n) -&gt; bool\n</code></pre> <p>Indicate if a handler is registered in the event manager.</p> <p>This method checks whether a specific event handler is registered, either for a specific event or across all events. Note that this method relies on the <code>equal</code> method of the input event handler to compare event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to search for in the registered handlers.</p> required <code>event</code> <code>str | None</code> <p>An event name (case-sensitive string) to check. If <code>None</code>, the method will search across all registered events. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nFalse\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n&gt;&gt;&gt; # Add an event handler\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nTrue\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_other_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_other_event\")\nFalse\n</code></pre>"},{"location":"refs/#minevent.EventManager.remove_event_handler","title":"minevent.EventManager.remove_event_handler","text":"<pre><code>remove_event_handler(\n    event: str, event_handler: BaseEventHandler\n) -&gt; None\n</code></pre> <p>Remove an event handler of a given event.</p> <p>This method removes all occurrences of the specified event handler from the given event. If the same event handler was added multiple times to the event, all duplicates are removed. This method relies on the <code>equal</code> method of the input event handler to compare event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) from which the handler should be removed.</p> required <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to remove from the event.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the event does not exist or if the handler is not attached to the event.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; # Remove the event handler of the engine\n&gt;&gt;&gt; manager.remove_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n</code></pre>"},{"location":"refs/#minevent.EventManager.reset","title":"minevent.EventManager.reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the event manager.</p> <p>This method removes all registered event handlers from the event manager and resets the last triggered event to <code>None</code>. After calling this method, the event manager returns to its initial state.</p> Example <pre><code>&gt;&gt;&gt; # Create an event manager\n&gt;&gt;&gt; from minevent import EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; # Add an event handler to the engine\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\n&gt;&gt;&gt; manager.last_triggered_event\nmy_event\n&gt;&gt;&gt; # Reset the event manager\n&gt;&gt;&gt; manager.reset()\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n&gt;&gt;&gt; manager.last_triggered_event\nNone\n</code></pre>"},{"location":"refs/#minevent.EventManager.trigger_event","title":"minevent.EventManager.trigger_event","text":"<pre><code>trigger_event(event: str) -&gt; None\n</code></pre> <p>Trigger the handler(s) for the given event.</p> <p>This method executes all event handlers registered for the specified event in the order they were added. The last triggered event name is updated regardless of whether any handlers are registered.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) to trigger.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")  # do nothing because there is no event handler\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n</code></pre>"},{"location":"refs/#minevent.PeriodicCondition","title":"minevent.PeriodicCondition","text":"<p>               Bases: <code>BaseCondition</code></p> <p>Implement a periodic condition.</p> <p>This condition evaluates to <code>True</code> every <code>freq</code> calls to the <code>evaluate</code> method. It maintains an internal counter that increments with each evaluation. The condition is <code>True</code> when the counter modulo <code>freq</code> equals zero.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>The frequency (interval) at which the condition evaluates to <code>True</code>. Must be a positive integer.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n</code></pre>"},{"location":"refs/#minevent.PeriodicCondition.freq","title":"minevent.PeriodicCondition.freq  <code>property</code>","text":"<pre><code>freq: int\n</code></pre> <p>Get the frequency of the periodic condition.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of evaluations between each <code>True</code> result. The condition evaluates to <code>True</code> every <code>freq</code> calls.</p>"},{"location":"refs/conditions/","title":"Conditions","text":""},{"location":"refs/conditions/#minevent.conditions","title":"minevent.conditions","text":"<p>Implement some conditions that can be used in the event system.</p>"},{"location":"refs/conditions/#minevent.conditions.BaseCondition","title":"minevent.conditions.BaseCondition","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement a condition for <code>ConditionalEventHandler</code>.</p> <p>A child class has to implement the following methods:</p> <pre><code>- ``evaluate``\n- ``equal``\n</code></pre> Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n</code></pre>"},{"location":"refs/conditions/#minevent.conditions.BaseCondition.equal","title":"minevent.conditions.BaseCondition.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Compare two conditions for equality.</p> <p>This method should be implemented by child classes to define how conditions are compared. This is used when comparing conditional event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with. Can be any type, though typically a condition.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two conditions are considered equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.equal(PeriodicCondition(freq=3))\nTrue\n&gt;&gt;&gt; condition.equal(PeriodicCondition(freq=2))\nFalse\n</code></pre>"},{"location":"refs/conditions/#minevent.conditions.BaseCondition.evaluate","title":"minevent.conditions.BaseCondition.evaluate  <code>abstractmethod</code>","text":"<pre><code>evaluate() -&gt; bool\n</code></pre> <p>Evaluate the condition given the current state.</p> <p>This method should be implemented by child classes to define the logic for determining whether a conditional event handler should be executed. The method is called without arguments and may maintain internal state between calls.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the condition is satisfied and the event handler logic should be executed, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/conditions/#minevent.conditions.PeriodicCondition","title":"minevent.conditions.PeriodicCondition","text":"<p>               Bases: <code>BaseCondition</code></p> <p>Implement a periodic condition.</p> <p>This condition evaluates to <code>True</code> every <code>freq</code> calls to the <code>evaluate</code> method. It maintains an internal counter that increments with each evaluation. The condition is <code>True</code> when the counter modulo <code>freq</code> equals zero.</p> <p>Parameters:</p> Name Type Description Default <code>freq</code> <code>int</code> <p>The frequency (interval) at which the condition evaluates to <code>True</code>. Must be a positive integer.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import PeriodicCondition\n&gt;&gt;&gt; condition = PeriodicCondition(freq=3)\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nFalse\n&gt;&gt;&gt; condition.evaluate()\nTrue\n</code></pre>"},{"location":"refs/conditions/#minevent.conditions.PeriodicCondition.freq","title":"minevent.conditions.PeriodicCondition.freq  <code>property</code>","text":"<pre><code>freq: int\n</code></pre> <p>Get the frequency of the periodic condition.</p> <p>Returns:</p> Type Description <code>int</code> <p>The number of evaluations between each <code>True</code> result. The condition evaluates to <code>True</code> every <code>freq</code> calls.</p>"},{"location":"refs/handlers/","title":"Handlers","text":""},{"location":"refs/handlers/#minevent.handlers","title":"minevent.handlers","text":"<p>Implement the event handlers.</p>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandler","title":"minevent.handlers.BaseEventHandler","text":"<p>               Bases: <code>ABC</code></p> <p>Define the base class to implement an event handler.</p> <p>A child class has to implement the following methods:</p> <pre><code>- ``handle``\n- ``equal``\n</code></pre> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandler.equal","title":"minevent.handlers.BaseEventHandler.equal  <code>abstractmethod</code>","text":"<pre><code>equal(other: Any) -&gt; bool\n</code></pre> <p>Compare two event handlers for equality.</p> <p>This method should be implemented by child classes to define how event handlers are compared. This is used by the event manager to check for duplicate handlers.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>The other object to compare with. Can be any type, though typically an event handler.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if the two event handlers are considered equal, otherwise <code>False</code>.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.equal(EventHandler(hello_handler))\nTrue\n&gt;&gt;&gt; handler.equal(EventHandler(print, handler_args=[\"Hello!\"]))\nFalse\n</code></pre>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandler.handle","title":"minevent.handlers.BaseEventHandler.handle  <code>abstractmethod</code>","text":"<pre><code>handle() -&gt; None\n</code></pre> <p>Handle the event.</p> <p>This method executes the logic associated with the event handler. It should be implemented by child classes to define the specific behavior when an event is triggered.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandlerWithArguments","title":"minevent.handlers.BaseEventHandlerWithArguments","text":"<p>               Bases: <code>BaseEventHandler</code></p> <p>Define a base class to implement an event handler with positional and/or keyword arguments.</p> <p>A child class has to implement the <code>equal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>The callable function or method to be invoked when the event is triggered.</p> required <code>handler_args</code> <code>Sequence[Any] | None</code> <p>The positional arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> <code>handler_kwargs</code> <code>dict[str, Any] | None</code> <p>The keyword arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler = EventHandler(print, handler_args=[\"Hello!\"])\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandlerWithArguments.handler","title":"minevent.handlers.BaseEventHandlerWithArguments.handler  <code>property</code>","text":"<pre><code>handler: Callable\n</code></pre> <p>Get the handler function.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>The handler function that will be called when the event is triggered.</p>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandlerWithArguments.handler_args","title":"minevent.handlers.BaseEventHandlerWithArguments.handler_args  <code>property</code>","text":"<pre><code>handler_args: tuple[Any]\n</code></pre> <p>Get the positional arguments for the handler.</p> <p>Returns:</p> Type Description <code>tuple[Any]</code> <p>A tuple containing the positional arguments that will be passed to the handler when it is called.</p>"},{"location":"refs/handlers/#minevent.handlers.BaseEventHandlerWithArguments.handler_kwargs","title":"minevent.handlers.BaseEventHandlerWithArguments.handler_kwargs  <code>property</code>","text":"<pre><code>handler_kwargs: dict[str, Any]\n</code></pre> <p>Get the keyword arguments for the handler.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the keyword arguments that will be passed to the handler when it is called.</p>"},{"location":"refs/handlers/#minevent.handlers.ConditionalEventHandler","title":"minevent.handlers.ConditionalEventHandler","text":"<p>               Bases: <code>BaseEventHandlerWithArguments</code></p> <p>Implement a conditional event handler.</p> <p>This class extends <code>BaseEventHandlerWithArguments</code> to add conditional execution. The handler is executed only if the associated condition evaluates to <code>True</code>. This is useful for scenarios where event handlers should only run under specific circumstances, such as periodic execution or state-based triggering.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>The callable function or method to be invoked when the event is triggered and the condition is <code>True</code>.</p> required <code>condition</code> <code>BaseCondition</code> <p>The condition object that controls whether the handler is executed. The condition's <code>evaluate</code> method is called without arguments and must return a boolean value.</p> required <code>handler_args</code> <code>Sequence[Any] | None</code> <p>The positional arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> <code>handler_kwargs</code> <code>dict[str, Any] | None</code> <p>The keyword arguments to pass to the handler when it is called. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import ConditionalEventHandler, PeriodicCondition\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = ConditionalEventHandler(hello_handler, PeriodicCondition(freq=3))\n&gt;&gt;&gt; handler\nConditionalEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n  (condition): PeriodicCondition(freq=3, step=0)\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/handlers/#minevent.handlers.ConditionalEventHandler.condition","title":"minevent.handlers.ConditionalEventHandler.condition  <code>property</code>","text":"<pre><code>condition: BaseCondition\n</code></pre> <p>Get the condition that controls handler execution.</p> <p>Returns:</p> Type Description <code>BaseCondition</code> <p>The condition that must evaluate to <code>True</code> for the handler to be executed.</p>"},{"location":"refs/handlers/#minevent.handlers.EventHandler","title":"minevent.handlers.EventHandler","text":"<p>               Bases: <code>BaseEventHandlerWithArguments</code></p> <p>Implement a simple event handler.</p> <p>This class wraps a callable function or method and allows it to be executed as an event handler. The handler can be configured with positional and keyword arguments that will be passed when the handler is executed.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; def hello_handler() -&gt; None:\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; handler = EventHandler(hello_handler)\n&gt;&gt;&gt; handler\nEventHandler(\n  (handler): &lt;function hello_handler at 0x...&gt;\n  (handler_args): ()\n  (handler_kwargs): {}\n)\n&gt;&gt;&gt; handler.handle()\nHello!\n</code></pre>"},{"location":"refs/manager/","title":"Manager","text":""},{"location":"refs/manager/#minevent.manager","title":"minevent.manager","text":"<p>Implement the event manager.</p>"},{"location":"refs/manager/#minevent.manager.EventManager","title":"minevent.manager.EventManager","text":"<p>Implement an event manager.</p> <p>This event manager allows registering event handlers and triggering events. An event is represented by a case-sensitive string. Each event can have multiple handlers attached, and all handlers are executed in the order they were added when the event is triggered. The manager also tracks the last triggered event.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.last_triggered_event","title":"minevent.manager.EventManager.last_triggered_event  <code>property</code>","text":"<pre><code>last_triggered_event: str | None\n</code></pre> <p>Get the last event name that was triggered.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>The last event name that was fired of <code>None</code> if no event was fired.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n&gt;&gt;&gt; manager.last_triggered_event\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.add_event_handler","title":"minevent.manager.EventManager.add_event_handler","text":"<pre><code>add_event_handler(\n    event: str, event_handler: BaseEventHandler\n) -&gt; None\n</code></pre> <p>Add an event handler to an event.</p> <p>The event handler will be called every time the specified event is triggered. Multiple handlers can be registered to the same event, and they will be executed in the order they were added.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) to which the event handler should be attached.</p> required <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to attach to the event.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import EventManager, EventHandler\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.has_event_handler","title":"minevent.manager.EventManager.has_event_handler","text":"<pre><code>has_event_handler(\n    event_handler: BaseEventHandler,\n    event: str | None = None,\n) -&gt; bool\n</code></pre> <p>Indicate if a handler is registered in the event manager.</p> <p>This method checks whether a specific event handler is registered, either for a specific event or across all events. Note that this method relies on the <code>equal</code> method of the input event handler to compare event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to search for in the registered handlers.</p> required <code>event</code> <code>str | None</code> <p>An event name (case-sensitive string) to check. If <code>None</code>, the method will search across all registered events. Default is <code>None</code>.</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nFalse\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n&gt;&gt;&gt; # Add an event handler\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler))\nTrue\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_other_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_other_event\")\nFalse\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.remove_event_handler","title":"minevent.manager.EventManager.remove_event_handler","text":"<pre><code>remove_event_handler(\n    event: str, event_handler: BaseEventHandler\n) -&gt; None\n</code></pre> <p>Remove an event handler of a given event.</p> <p>This method removes all occurrences of the specified event handler from the given event. If the same event handler was added multiple times to the event, all duplicates are removed. This method relies on the <code>equal</code> method of the input event handler to compare event handlers.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) from which the handler should be removed.</p> required <code>event_handler</code> <code>BaseEventHandler</code> <p>The event handler instance to remove from the event.</p> required <p>Raises:</p> Type Description <code>RuntimeError</code> <p>if the event does not exist or if the handler is not attached to the event.</p> Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; # Remove the event handler of the engine\n&gt;&gt;&gt; manager.remove_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.reset","title":"minevent.manager.EventManager.reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the event manager.</p> <p>This method removes all registered event handlers from the event manager and resets the last triggered event to <code>None</code>. After calling this method, the event manager returns to its initial state.</p> Example <pre><code>&gt;&gt;&gt; # Create an event manager\n&gt;&gt;&gt; from minevent import EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; # Add an event handler to the engine\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; from minevent import EventHandler\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nTrue\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\n&gt;&gt;&gt; manager.last_triggered_event\nmy_event\n&gt;&gt;&gt; # Reset the event manager\n&gt;&gt;&gt; manager.reset()\n&gt;&gt;&gt; # Check if `hello_handler` is registered in the event manager for 'my_event' event\n&gt;&gt;&gt; manager.has_event_handler(EventHandler(hello_handler), \"my_event\")\nFalse\n&gt;&gt;&gt; manager.last_triggered_event\nNone\n</code></pre>"},{"location":"refs/manager/#minevent.manager.EventManager.trigger_event","title":"minevent.manager.EventManager.trigger_event","text":"<pre><code>trigger_event(event: str) -&gt; None\n</code></pre> <p>Trigger the handler(s) for the given event.</p> <p>This method executes all event handlers registered for the specified event in the order they were added. The last triggered event name is updated regardless of whether any handlers are registered.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>str</code> <p>The event name (case-sensitive string) to trigger.</p> required Example <pre><code>&gt;&gt;&gt; from minevent import EventHandler, EventManager\n&gt;&gt;&gt; manager = EventManager()\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")  # do nothing because there is no event handler\n&gt;&gt;&gt; def hello_handler():\n...     print(\"Hello!\")\n...\n&gt;&gt;&gt; manager.add_event_handler(\"my_event\", EventHandler(hello_handler))\n&gt;&gt;&gt; manager.trigger_event(\"my_event\")\nHello!\n</code></pre>"}]}